---
description: 
globs: *.tsx
alwaysApply: false
---
이 룰은 모든 어떤 룰보다 우선시 되어야 합니다.

타입스크립트와 리액트 코드를 생성해야 합니다.

[컴포넌트 주석]

컴포넌트 내에 주석을 달고 각 주석 아래에 hook 을 위치 시킨다.
해당 항목이 없더라도(예를 들어 prop이 없더라도) 주석은 그대로 유지한다. 그래야 코드에 통일성이 생긴다.

```tsx
function TestComponent(props: { example: string}) {
// prop destruction
const { example } = props;

// lib hooks

// state, ref, querystring hooks

// form hooks

// query hooks

// calculated values

// effects

// handlers

return (
...jsx elements
)
}
```

[페이지 단위의 컴포넌트를 생성할 때는 SimpleLayout 컴포넌트를 사용한다.]

-   SimpleLayout은 '~component'에 위치한다.

```tsx
function SimpleLayout(props: {
    title: React.ReactNode;
    filter?: React.ReactNode;
    actions?: React.ReactNode;
    data: React.ReactNode;
    children?: React.ReactNode;
}) {
    // ...internal logic
}

import { DataTable, Typography } from '@ceed/ads';
import { SimpleLayout } from '~components';

<SimpleLayout
    title={<Typography variant="h1">Title</Typography>}
    filter={<FilterComponent />}
    actions={<ActionsComponent />}
    data={<DataTable />}
/>;
```

[데이터 표현은 DataTable 컴포넌트를 사용한다.]

-   컴포넌트 내에서 변수를 정의하고, useMemo와 useCallback을 사용한다.
-   DataTable을 사용하기 위해서는 columns를 정의해야 한다. columns는 ColumnDef 타입을 사용한다.
-   rows는 데이터 배열을 받는다.
-   DataTable은 '@ceed/ads'에 위치한다.
-   type ColumnDef는 '@ceed/ads/dist/components/DataTable/types'에 위치한다. 반드시 type import로 가져온다.
-   columns와 rows는 반드시 memoization 되어 있어야 한다.

```tsx
type DataTableProps<T extends Record<PropertyKey, any>, GetId extends ((row: T) => any) | undefined> = {
    rows: T[];
    checkboxSelection?: boolean;
    columns: ColumnDef<T, InferredIdType<T, GetId>>[];
    editMode?: boolean;
    // 체크박스가 있는 경우, 체크박스를 클릭했을 때 선택된 row의 index를 지정한다.
    selectionModel?: InferredIdType<T, GetId>[];
    onSelectionModelChange?: (
        newSelectionModel: InferredIdType<T, GetId>[],
        // Total Select를 클릭한 경우에만 값이 true/false로 들어온다.
        // MUI에는 없는 인터페이스지만 Total Select 기능이 추가되었기 때문에 추가해야했다.
        isTotalSelected?: boolean,
    ) => void;
    disableSelectionOnClick?: boolean;
    initialState?: Partial<{
        sorting: Partial<{
            sortModel: SortModel<T>[];
        }>;
    }>;
    pagination?: boolean;
    paginationMode?: 'client' | 'server';
    paginationModel?: {
        page: number;
        pageSize: number;
    };
    onPaginationModelChange?: (model: { page: number; pageSize: number }) => void;
    // 여기서부터 Sort관련 props
    sortModel?: SortModel<T>[];
    sortOrder?: Sort[];
    onSortModelChange?: (model: SortModel<T>[]) => void;
    // Rows의 총 갯수를 직접 지정 할 수 있다.
    // 기본적으로는 rows.length를 사용하지만, 이 값을 지정하면 rows.length를 사용하지 않는다.
    // server mode를 사용할 때 유용하다.
    rowCount?: number;
    loading?: boolean;
    getId?: GetId;
    onRowClick?: (
        params: {
            row: T;
            rowId: InferredIdType<T, GetId>;
        },
        event: React.MouseEvent,
    ) => void;
    // 기본적으로 Uncontrolled로 작동하지만, Controlled로 작동하게 하고 싶을 때 사용한다.
    // 이 값이 true이면, 현재 페이지 이외에도 존재하는 모든 데이터가 선택된것으로 간주하고 동작한다.
    isTotalSelected?: boolean;
    slots?: {
        checkbox?: React.ElementType;
        toolbar?: React.ElementType;
        footer?: React.ElementType;
        loadingOverlay?: React.ElementType;
    };
    slotProps?: {
        checkbox?: Partial<{
            checked: boolean;
            [key: string]: any;
        }>;
        toolbar?: Partial<{
            [key: string]: any;
        }>;
        background?: Partial<{
            [key: string]: any;
        }>;
    };
} & ComponentProps<typeof Table>;

type BaseColumnDef<T extends Record<PropertyKey, V>, V, ID> = {
    [K in keyof T]: {
        field: K;
        headerName?: string;
        width?: string;
        minWidth?: string;
        maxWidth?: string;
        resizable?: boolean;
        renderCell?: RenderCellHandler<T, ID, T[K]>;
        renderEditCell?: RenderCellHandler<T, ID, T[K]>;
        isCellEditable?: CellEditableHandler<T, ID, V> | boolean;
        required?: boolean;
        onCellEditStart?: CellEditStartEvent<T, ID, V>;
        onCellEditStop?: CellEditStopEvent<T, ID, V>;
        sortable?: boolean;
        sortComparator?: (params: { rowA: T; rowB: T }) => number;
        sortOrder?: Sort[];
        // Tooltip 으로 노출되는 설명
        description?: string;
    };
}[keyof T];
```

[Props를 위한 타입 분리 금지]

-   Props를 위한 Type Alias 또는 Interface를 추가 정의하지 않는다.

```tsx
function TestComponent(props: {
    type: {
        a: string;
        b: number;
    };
    example: string;
}) {
    // prop destruction
    const { type, example } = props;
    // lib hooks

    // state, ref, querystring hooks

    // form hooks

    // query hooks

    // calculated values

    // effects

    // handlers
    return <div>{example}</div>;
}
```

[컴포넌트 export]

```tsx
export { Component };
```
[코드에는 모두 영문을 사용한다. 단, 주석은 한글이 허용된다.]
- 모든 코드에는 문자열에 들어가는 내용에도 무조건 영문으로 작성한다.
- 한글은 절대 사용하지 않는다.

[주석 컨벤션]
- 주석의 종류는 다음과 같다.
  - NOTE:
    - 주목 필요한 부분
    - 그냥 주석과 차이는 없지만 하이라이트 시켜서 개발자가 한번 더 읽어 보도록 하기 위한 용도
  - TODO:
    - 아직 구현되지 않았지만 언젠가 해야 하는 일
  - FIXME:
    - 빠른 시간 내에 해야 하는 일
    - 어떤 목적(최적화, 리팩토링 등)을 달성하기 위해 코드를 고칠 필요가 있음
  - HACK:
    - 주석이 없다면 왜 이렇게 코딩했을지 알 수 없는 예상치 못한 방법을 사용함
  - OPTIMIZE:
    - 최적화가 필요한 부분
  - BUG:
    - 버그가 있는 코드
  - HARDCODING:
    - 하드코딩된 값
